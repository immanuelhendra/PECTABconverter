<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF text + barcode extractor (robust loader)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 0; background:#0b1220; color:#e6edf3}
  .wrap { display:grid; grid-template-columns: 360px 1fr 420px; gap:12px; padding:12px; height:100vh; box-sizing:border-box }
  section { border:1px solid #223357; border-radius:12px; padding:10px; background:#0f1a30; overflow:auto }
  h2 { margin:6px 0 10px; font-size:14px; color:#c9d7f1 }
  input, button { width:100%; padding:10px; border-radius:10px; border:1px solid #2a406e; background:#0b162c; color:#e6edf3; }
  button { cursor:pointer }
  .row{ display:flex; gap:8px; margin-top:8px }
  canvas { width:100%; height:auto; background:#071023; border:1px solid #223357; border-radius:8px }
  pre { white-space:pre-wrap; word-wrap:anywhere; font-family:ui-monospace, Menlo, Consolas, monospace; font-size:12px; line-height:1.35; }
  .pill { display:inline-block; font-size:11px; padding:2px 8px; border:1px solid #345; border-radius:999px; background:#0c203a; color:#9ad; }
</style>
</head>
<body>
<div class="wrap">
  <section>
    <h2>1) Load</h2>
    <input id="file" type="file" accept="application/pdf" />
    <div class="row">
      <input id="page" type="number" value="1" min="1" />
      <input id="scale" type="number" value="2.0" step="0.1" min="0.5" max="5" />
    </div>
    <div class="row">
      <button id="render" disabled>Render</button>
      <button id="detect">Detect</button>
    </div>
    <div class="row"><pre id="log">log…</pre></div>
  </section>

  <section>
    <h2>2) Page</h2>
    <canvas id="c"></canvas>
  </section>

  <section>
    <h2>3) Results</h2>
    <div><span class="pill">Text items</span></div>
    <pre id="text"></pre>
    <div><span class="pill">Barcode</span></div>
    <pre id="barcode"></pre>
  </section>
</div>

<!-- libs (CDN) -->
<script src="https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.worker.min.js";</script>
<script src="https://unpkg.com/@zxing/library@0.21.3"></script>

<script>
const $ = s => document.querySelector(s);
const log = (...a)=>{ const el=$("#log"); el.textContent += "\n• "+a.join(" "); console.log(...a) };

const state = { pdf:null, page:null, viewport:null, loading:false };
const canvas = $("#c"), ctx = canvas.getContext("2d");

// -------- Robust loader: arrayBuffer -> Blob URL fallback
async function loadSelectedFile() {
  if (state.loading) return;
  const inp = $("#file");
  const file = inp && inp.files && inp.files[0];
  if (!file) { log("No file selected"); return; }
  state.loading = true;
  $("#render").disabled = true;

  try {
    let pdfPromise;
    try {
      const buf = await file.arrayBuffer();                    // primary path
      pdfPromise = pdfjsLib.getDocument({ data: buf });
    } catch (e) {
      const blobUrl = URL.createObjectURL(file);               // fallback path
      pdfPromise = pdfjsLib.getDocument({
        url: blobUrl,
        useWorkerFetch: false,
        isEvalSupported: true,
      });
    }
    state.pdf = await pdfPromise.promise;
    $("#page").max = state.pdf.numPages;
    $("#page").value = 1;
    log(`Loaded ${file.name}, pages=${state.pdf.numPages}`);
  } catch (err) {
    log("PDF load error:", err.message);
    console.error(err);
    state.pdf = null;
  } finally {
    state.loading = false;
    $("#render").disabled = !state.pdf;
  }
}

$("#file").addEventListener("change", loadSelectedFile);
$("#file").addEventListener("input", loadSelectedFile);

// -------- Render (waits for load if needed)
$("#render").addEventListener("click", async ()=>{
  if(!state.pdf){
    await loadSelectedFile();
    if(!state.pdf){ log("Render aborted: still no PDF loaded"); return; }
  }
  try{
    const n = +$("#page").value || 1;
    const s = +$("#scale").value || 2.0;
    state.page = await state.pdf.getPage(n);
    state.viewport = state.page.getViewport({scale:s});
    canvas.width = state.viewport.width; canvas.height = state.viewport.height;
    await state.page.render({ canvasContext: ctx, viewport: state.viewport }).promise;
    log(`Rendered page ${n} @ scale ${s}`);
  }catch(err){ log("Render error:", err.message) }
});

// -------- Detect text + barcode
$("#detect").addEventListener("click", async ()=>{
  $("#text").textContent = "";
  $("#barcode").textContent = "";
  drawOverlay(); // clear
  await detectText();
  await detectBarcode();
  drawOverlay(true);
});

async function detectText(){
  if(!state.page){ log("DetectText: no page"); return }
  try{
    const tc = await state.page.getTextContent();
    const vp = state.viewport;
    const rows = [];
    for(const item of tc.items){
      const tr = pdfjsLib.Util.transform(vp.transform, item.transform);
      const x = tr[4];
      const yTop = tr[5] - item.height; // convert PDF bottom-left to canvas top-left
      const w = item.width, h = item.height;
      const text = (item.str||"").trim();
      if(!text) continue;
      rows.push({text, x:Math.round(x), y:Math.round(yTop), w:Math.round(w), h:Math.round(h)});
    }
    $("#text").textContent = rows.map(r=>`${r.text}  |  x=${r.x}, y=${r.y}, w=${r.w}, h=${r.h}`).join("\n");
    state.textRects = rows.map(r=>({x:r.x,y:r.y,w:r.w,h:r.h}));
    log(`Text items: ${rows.length}`);
  }catch(err){ log("Text error:", err.message) }
}

async function detectBarcode(){
  try{
    if(!canvas.width||!canvas.height){ log("Barcode: empty canvas"); return }
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const lumin = new ZXing.RGBLuminanceSource(img.data, canvas.width, canvas.height);
    let bin = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(lumin));
    const reader = new ZXing.MultiFormatReader();
    const hints = new Map();
    hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
      ZXing.BarcodeFormat.PDF_417,
      ZXing.BarcodeFormat.CODE_128,
      ZXing.BarcodeFormat.CODE_39,
      ZXing.BarcodeFormat.QR_CODE,
      ZXing.BarcodeFormat.ITF,
      ZXing.BarcodeFormat.EAN_13,
      ZXing.BarcodeFormat.EAN_8,
    ]);
    reader.setHints(hints);

    let res = null, rotated = false;
    try { res = reader.decode(bin); }
    catch(e){
      // try rotated 90° CCW
      const rot = lumin.rotateCounterClockwise();
      bin = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(rot));
      res = reader.decode(bin);
      rotated = true;
    }

    if(res){
      const text = res.getText ? res.getText() : String(res.text || "");
      const fmt  = res.getBarcodeFormat ? res.getBarcodeFormat() : "AUTO";
      // Try to build a rectangle from result points (if provided)
      let rect = null;
      try{
        const pts = res.getResultPoints ? res.getResultPoints() : null;
        if(pts && pts.length){
          const xs = pts.map(p=>p.getX()), ys = pts.map(p=>p.getY());
          const x = Math.min(...xs), y = Math.min(...ys);
          const w = Math.max(...xs)-x, h = Math.max(...ys)-y;
          if(w>5 && h>5) rect = {x,y,w,h};
        }
      }catch(_){}
      if(!rect) rect = {x:20,y:20,w:canvas.width-40,h:120}; // conservative fallback

      $("#barcode").textContent =
        `value=${text}\nformat=${fmt}${rotated?' (rotated pass)':''}\nrect: x=${rect.x}, y=${rect.y}, w=${rect.w}, h=${rect.h}`;
      state.barRect = rect;
      log(`Barcode OK (${fmt})`);
    } else {
      $("#barcode").textContent = "No barcode found. Try higher Scale (2.0–3.0) and re-render.";
      state.barRect = null;
      log("Barcode not found");
    }
  }catch(err){
    $("#barcode").textContent = "Barcode error: "+err.message;
    log("Barcode error:", err.message);
  }
}

function drawOverlay(final=false){
  if(!state.page) return;
  ctx.save();
  if(state.textRects){
    ctx.strokeStyle = final ? "#60a5fa" : "#224";
    ctx.lineWidth = 2;
    for(const r of state.textRects){ ctx.strokeRect(r.x, r.y, r.w, r.h); }
  }
  if(state.barRect){
    const r = state.barRect; ctx.strokeStyle = "#fbbf24"; ctx.lineWidth = 3; ctx.strokeRect(r.x,r.y,r.w,r.h);
  }
  ctx.restore();
}
</script>
</body>
</html>

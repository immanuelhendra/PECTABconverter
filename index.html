<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Base64 → PECTAB Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, Arial, sans-serif; }
    body { margin: 24px; }
    h1 { margin: 0 0 8px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 1100px; }
    textarea, input, select, button { width: 100%; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    textarea { min-height: 160px; }
    .row { display: grid; gap: 16px; grid-template-columns: 1fr 1fr; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; box-shadow: 0 2px 6px rgba(0,0,0,.05); }
    .muted { color: #666; }
    pre { background: #0b1020; color: #e7eeff; padding: 12px; border-radius: 8px; overflow: auto; }
    .small { font-size: 12px; }
    .btn { cursor: pointer; border: 1px solid #333; border-radius: 8px; background: #111; color: #fff; }
    .btn.secondary { background: #fff; color: #111; }
    .flex { display: flex; gap: 8px; align-items: center; }
    .nowrap { white-space: nowrap; }
  </style>
</head>
<body>
  <h1>Base64 → PECTAB Generator</h1>
  <p class="muted small">
    Paste a Base64 payload, decode, and generate a PECTAB-like template.
    <span class="nowrap">Adjust fields below if needed.</span>
  </p>

  <div class="grid">
    <div class="card">
      <h3>1) Paste Base64 input</h3>
      <textarea id="b64Input" placeholder="Paste your Base64 string here..."></textarea>
      <div class="flex">
        <button id="decodeBtn" class="btn">Decode</button>
        <button id="clearBtn" class="btn secondary">Clear</button>
      </div>
      <p class="small muted">Tip: The decoded data can be JSON (recommended, see schema), or free text with an embedded data URI (data:image/...;base64,...).</p>
    </div>

    <div class="row">
      <div class="card">
        <h3>2) Decoded payload (preview)</h3>
        <textarea id="decoded" placeholder="Decoded content appears here..." readonly></textarea>
      </div>
      <div class="card">
        <h3>3) Parsed fields (editable)</h3>
        <label class="small muted">Text blocks (JSON)</label>
        <textarea id="textBlocks"></textarea>

        <div class="row">
          <div>
            <label class="small muted">Barcode symbology</label>
            <select id="barcodeSym">
              <option>PDF417</option>
              <option>QR</option>
              <option>DATAMATRIX</option>
              <option>AZTEC</option>
            </select>
          </div>
          <div>
            <label class="small muted">Barcode module width (dots)</label>
            <input id="barcodeModule" type="number" value="2" />
          </div>
        </div>

        <div class="row">
          <div>
            <label class="small muted">Barcode X</label>
            <input id="barcodeX" type="number" value="10" />
          </div>
          <div>
            <label class="small muted">Barcode Y</label>
            <input id="barcodeY" type="number" value="60" />
          </div>
        </div>

        <label class="small muted">Barcode data</label>
        <textarea id="barcodeData"></textarea>

        <div class="flex">
          <label class="small muted"><input type="checkbox" id="barcodeIsB64" /> barcodeData is Base64</label>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>4) Generated PECTAB (editable/exportable)</h3>
      <pre id="pectabOut"></pre>
      <div class="flex">
        <button id="genBtn" class="btn">Generate / Refresh</button>
        <button id="downloadBtn" class="btn secondary">Download .pectab</button>
      </div>
      <p class="small muted">
        This is a generic PECTAB-style output: coordinates & fields with a simple barcode command. You’ll likely need to align
        the keywords to your host/printer’s PECTAB dialect (vendor docs). For boarding-pass/ATB contexts, PECTAB defines *where* text & barcodes render. :contentReference[oaicite:1]{index=1}
      </p>
    </div>
  </div>

  <script>
    // --- Utilities ---
    function decodeBase64Unicode(b64) {
      // Handle URL-safe variants and whitespace
      const norm = b64.replace(/[\r\n\s]/g, '').replace(/-/g, '+').replace(/_/g, '/');
      const bin = atob(norm);
      // Convert binary string to UTF-8 string
      const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
      const dec = new TextDecoder('utf-8', { fatal: false });
      return dec.decode(bytes);
    }

    function tryParseJSON(s) {
      try { return JSON.parse(s); } catch { return null; }
    }

    function extractImageDataURI(s) {
      const m = s.match(/data:image\\/(?:png|gif|jpeg|jpg|bmp|webp);base64,([A-Za-z0-9+/=]+)/i);
      return m ? m[1] : null;
    }

    function defaultTextBlocksFromPlainText(s) {
      const lines = s.split(/\\r?\\n/).map(t => t.trim()).filter(Boolean);
      const blocks = [];
      let y = 10;
      for (const line of lines) {
        blocks.push({ x: 10, y, font: "A", size: 10, text: line });
        y += 12;
      }
      return blocks;
    }

    // --- Build a "generic" PECTAB string ---
    // This is a simplified, human-readable template reflecting the parametric idea:
    //  - HEADER, PAGE size
    //  - TEXT fields with X/Y, FONT/SIZE
    //  - BARCODE with SYMBOLOGY and payload
    // Adapt these keywords to your printer's PECTAB dialect.
    function buildPectab({ page = { width: 203, height: 127 }, textBlocks = [], barcode = null }) {
      const lines = [];
      lines.push("; ---- GENERIC PECTAB START ----");
      lines.push(`PAGE WIDTH=${page.width} HEIGHT=${page.height}  ; units: dots`);
      lines.push("");

      // Text fields
      textBlocks.forEach((t, i) => {
        const font = t.font || "A";
        const size = t.size || 10;
        const x = t.x ?? 10;
        const y = t.y ?? (10 + i * 12);
        const text = (t.text ?? "").replace(/\\r?\\n/g, " ");
        lines.push(`TEXT X=${x} Y=${y} FONT=${font} SIZE=${size} : ${text}`);
      });

      lines.push("");

      if (barcode && barcode.data) {
        const sym = (barcode.symbology || "PDF417").toUpperCase();
        const x = barcode.x ?? 10;
        const y = barcode.y ?? 60;
        const mod = barcode.moduleWidth ?? 2;
        const rowH = barcode.rowHeight ?? 6;

        // If barcode data provided as Base64 (of bytes), decode to text safely.
        let payload = barcode.data;
        if (barcode.isBase64) {
          try {
            payload = decodeBase64Unicode(barcode.data);
          } catch {
            // keep original if decode fails
            payload = barcode.data;
          }
        }

        // Many PECTAB implementations expect the raw data string (e.g., BCBP)
        lines.push(`BARCODE SYMBOLOGY=${sym} X=${x} Y=${y} MODULE=${mod} ROWH=${rowH}`);
        lines.push(`BARCODE-DATA: ${payload}`);
      } else {
        lines.push("; (No barcode provided)");
      }

      lines.push("");
      lines.push("; ---- GENERIC PECTAB END ----");
      return lines.join("\\n");
    }

    // --- Wiring UI ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    const elB64Input = $("#b64Input");
    const elDecoded = $("#decoded");
    const elTextBlocks = $("#textBlocks");
    const elBarcodeSym = $("#barcodeSym");
    const elBarcodeModule = $("#barcodeModule");
    const elBarcodeX = $("#barcodeX");
    const elBarcodeY = $("#barcodeY");
    const elBarcodeData = $("#barcodeData");
    const elBarcodeIsB64 = $("#barcodeIsB64");
    const elPectabOut = $("#pectabOut");

    $("#clearBtn").addEventListener("click", () => {
      elB64Input.value = "";
      elDecoded.value = "";
      elTextBlocks.value = "";
      elBarcodeData.value = "";
      elPectabOut.textContent = "";
    });

    $("#decodeBtn").addEventListener("click", () => {
      const raw = elB64Input.value.trim();
      if (!raw) return;
      let decoded = "";
      try {
        decoded = decodeBase64Unicode(raw);
      } catch (e) {
        alert("Invalid Base64 input.");
        return;
      }
      elDecoded.value = decoded;

      // Try JSON first
      const obj = tryParseJSON(decoded);
      if (obj && typeof obj === "object") {
        // Populate textBlocks
        const tb = Array.isArray(obj.textBlocks) ? obj.textBlocks : [];
        elTextBlocks.value = JSON.stringify(tb, null, 2);

        // Barcode
        if (obj.barcode && (obj.barcode.data || obj.barcode.payload)) {
          const b = obj.barcode;
          elBarcodeSym.value = (b.symbology || "PDF417").toUpperCase();
          elBarcodeModule.value = (b.moduleWidth ?? 2);
          elBarcodeX.value = (b.x ?? 10);
          elBarcodeY.value = (b.y ?? 60);
          elBarcodeData.value = (b.data || b.payload || "");
          elBarcodeIsB64.checked = !!obj.barcodeDataIsBase64 || !!b.isBase64;
        } else {
          // check if there's an inline data URI in any string
          const maybeImgB64 = extractImageDataURI(decoded);
          elBarcodeData.value = maybeImgB64 ? maybeImgB64 : "";
          elBarcodeIsB64.checked = !!maybeImgB64;
        }

        if (!tb.length) {
          // fallback: derive text blocks from any known plain fields, else from the whole text
          elTextBlocks.value = JSON.stringify(defaultTextBlocksFromPlainText(decoded), null, 2);
        }
      } else {
        // Non-JSON payload: try to split text & image
        const maybeImgB64 = extractImageDataURI(decoded);
        const textOnly = maybeImgB64 ? decoded.replace(/data:image\\/(?:png|gif|jpeg|jpg|bmp|webp);base64,[A-Za-z0-9+/=]+/i, "").trim() : decoded;

        elTextBlocks.value = JSON.stringify(defaultTextBlocksFromPlainText(textOnly), null, 2);
        elBarcodeData.value = maybeImgB64 ? maybeImgB64 : "";
        elBarcodeIsB64.checked = !!maybeImgB64;
      }
    });

    $("#genBtn").addEventListener("click", () => {
      let tb = [];
      try { tb = JSON.parse(elTextBlocks.value || "[]"); } catch { tb = []; }
      const pectab = buildPectab({
        textBlocks: tb,
        barcode: {
          symbology: elBarcodeSym.value,
          moduleWidth: Number(elBarcodeModule.value) || 2,
          rowHeight: 6,
          x: Number(elBarcodeX.value) || 10,
          y: Number(elBarcodeY.value) || 60,
          data: elBarcodeData.value.trim(),
          isBase64: elBarcodeIsB64.checked
        }
      });
      elPectabOut.textContent = pectab;
    });

    $("#downloadBtn").addEventListener("click", () => {
      const blob = new Blob([elPectabOut.textContent || ""], { type: "text/plain" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "output.pectab";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    });

    // Seed an example for convenience
    elB64Input.value = btoa(JSON.stringify({
      textBlocks: [
        { x: 10, y: 20, font: "A", size: 10, text: "Passenger: Ada Lovelace" },
        { x: 10, y: 34, font: "A", size: 10, text: "Flight: AB123 2025-11-01" },
        { x: 10, y: 48, font: "A", size: 10, text: "Seat: 12C   Gate: C5" }
      ],
      barcode: {
        symbology: "PDF417",
        moduleWidth: 2,
        rowHeight: 6,
        x: 10, y: 70,
        data: "M1LOVELACE/ADA  AB123XYZ SINLHR 0123 12C 20251101" // sample BCBP-like string
      },
      barcodeDataIsBase64: false
    }, null, 2));
  </script>
</body>
</html>

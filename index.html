<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PDF → PECTAB Converter</title>
<style>
  :root { --bg:#0b1220; --panel:#111a2b; --ink:#e6edf3; --muted:#92a0b3; --accent:#5eead4; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--ink); }
  header { padding: 16px 20px; display:flex; align-items:center; gap:14px; border-bottom:1px solid #1f2a44; position:sticky; top:0; background:linear-gradient(180deg,var(--bg),#0b1220f2 70%, #0b122000); z-index:5; }
  header h1 { font-size: 18px; margin:0; font-weight:600; letter-spacing: .3px; }
  header .hint{ color: var(--muted); font-size:12px; }
  main { display:grid; grid-template-columns: 420px 1fr 360px; gap:16px; padding:16px; height: calc(100% - 60px); }
  section { background: var(--panel); border:1px solid #1f2a44; border-radius: 14px; overflow: hidden; }
  section header { background: transparent; position: static; border:0; padding:12px 14px; display:flex; align-items:center; justify-content:space-between; }
  section header h2 { font-size: 14px; margin: 0; color: #cbd5e1; letter-spacing:.2px; }
  .scroll { height: calc(100% - 44px); overflow: auto; padding: 12px; }
  .controls label { display:block; margin:10px 0 4px; font-size:12px; color:var(--muted); }
  input[type=file], select, button, textarea, input[type=text], input[type=number]{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid #203052; color:var(--ink); background:#0e1728; outline:none; }
  button{ cursor:pointer; background:#0f223f; border:1px solid #233a64; transition:all .15s ease; }
  button:hover{ border-color:#2b4d82; transform: translateY(-1px); }
  button.accent{ background: #0b312e; border-color:#1b4a44; }
  canvas { width:100%; height:auto; background:#0b1220; border-radius: 8px; border:1px solid #1f2a44; }
  .row{ display:flex; gap:8px; }
  .row>*{ flex:1; }
  .inline { display:flex; gap:8px; align-items:center; }
  .pill { font-size:11px; color:#93e5d8; background:#0c2b28; padding:4px 8px; border-radius:999px; border:1px solid #214e47; }
  .det { border:1px solid #263a60; border-radius:12px; padding:8px; margin-bottom:10px; background:#0d1628; }
  .det h4 { margin:0 0 6px 0; font-size:12px; color:#cdd8ea; }
  .det small{ color:var(--muted); }
  .kbd{ font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
  .out{ height:220px; }
  .footer { font-size:12px; color:var(--muted); padding:10px 12px; border-top:1px dashed #1f2a44; }
  .badge{ font-size:10px; padding:2px 6px; border-radius:6px; border:1px solid #334d80; background:#0f1a30; color:#b9c6e4; }
  .ghost{ opacity:.75 }
  .link { color:#93c5fd; text-decoration:none; }
</style>
</head>
<body>
  <header>
    <h1>PDF → PECTAB Converter</h1>
    <span class="hint">Client‑side tool to detect text & barcodes, map them to fields, and export draft PECTAB + data.</span>
  </header>
  <main>
    <!-- Left: Controls -->
    <section>
      <header>
        <h2>1) Load PDF & Options</h2>
      </header>
      <div class="scroll controls">
        <label>PDF file</label>
        <input type="file" id="pdfFile" accept="application/pdf" />

        <div class="row">
          <div>
            <label>Page</label>
            <input type="number" id="pageNum" value="1" min="1" />
          </div>
          <div>
            <label>Scale</label>
            <input type="number" id="scale" value="1.5" step="0.1" min="0.5" max="4" />
          </div>
        </div>

        <div class="row">
          <button id="render">Render Page</button>
          <button id="autodetect" class="accent">Auto‑detect (text + barcodes)</button>
        </div>

        <hr style="border-color:#1f2a44; margin:14px 0"/>

        <h3 class="pill">Detection settings</h3>
        <label class="inline"><input type="checkbox" id="usePdfText" checked style="width:auto"> <span>Use PDF text layer</span></label>
        <label class="inline"><input type="checkbox" id="useOCR" style="width:auto"> <span>Use OCR fallback (Tesseract)</span></label>
        <label class="inline"><input type="checkbox" id="useBarcode" checked style="width:auto"> <span>Detect barcodes (PDF417/QR/1D)</span></label>

        <p class="footer">Tip: If your PDF is a scan, enable OCR. If it has selectable text, the text layer is faster and more accurate.</p>

        <h3 class="pill">Field presets</h3>
        <small class="ghost">Select a preset to create common PECTAB fields for ATB/BTP. You can edit afterwards.</small>
        <div class="row" style="margin-top:8px">
          <button id="presetATB">Add ATB Preset</button>
          <button id="presetBTP">Add BTP Preset</button>
        </div>

        <h3 class="pill" style="margin-top:14px">Export</h3>
        <div class="row" style="margin-top:6px">
          <button id="exportPectab" class="accent">Generate PECTAB</button>
          <button id="exportJSON">Export JSON</button>
        </div>
        <div class="row" style="margin-top:6px">
          <button id="clearAll">Clear detections</button>
        </div>
      </div>
    </section>

    <!-- Middle: Canvas -->
    <section>
      <header>
        <h2>2) Page preview (draw or edit boxes)</h2>
        <span class="badge">Drag to draw, click a box to select, ⌫ to remove</span>
      </header>
      <div class="scroll">
        <canvas id="pageCanvas"></canvas>
      </div>
    </section>

    <!-- Right: Detections & Output -->
    <section>
      <header>
        <h2>3) Detections & Mapping</h2>
        <span class="badge">Map each detection to a field</span>
      </header>
      <div class="scroll" id="detList"></div>
      <div class="footer">
        <div class="row">
          <div>
            <label>PECTAB (layout)</label>
            <textarea id="pectabOut" class="out kbd" placeholder="Generated PECTAB layout will appear here…"></textarea>
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label>Data (ATB/BTP)</label>
            <textarea id="dataOut" class="out kbd" placeholder="Generated PECTAB data string (from mapped fields)…"></textarea>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Libraries via CDN -->
  <script src="https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.worker.min.js";</script>
  <script src="https://unpkg.com/@zxing/library@0.21.3"></script>
  <script src="https://unpkg.com/tesseract.js@5.0.5/dist/tesseract.min.js"></script>

  <script>
  // ---------- Minimal state ----------
  const $ = (s, el=document) => el.querySelector(s);
  const $$ = (s, el=document) => [...el.querySelectorAll(s)];
  const state = {
    pdf: null,
    page: null,
    pageNum: 1,
    scale: 1.5,
    detections: [],      // {id, type:'text'|'barcode', value, rect:{x,y,w,h}, conf, fieldName, font, size, align}
    selectedId: null,
  };

  const canvas = document.getElementById('pageCanvas');
  const ctx = canvas.getContext('2d');

  // ---------- Rendering ----------
  async function renderPage() {
    if (!state.pdf) return;
    state.pageNum = Number($('#pageNum').value || 1);
    state.scale = Number($('#scale').value || 1.5);

    const page = await state.pdf.getPage(state.pageNum);
    state.page = page;
    const viewport = page.getViewport({ scale: state.scale });
    canvas.width = viewport.width; canvas.height = viewport.height;

    const renderTask = page.render({ canvasContext: ctx, viewport });
    await renderTask.promise;

    drawOverlay();
  }

  function drawOverlay() {
    if (!state.page) return;
    // Repaint page by re-rendering last frame stored in canvas (already drawn)
    // Draw selections
    ctx.save();
    for (const det of state.detections) {
      const {x,y,w,h} = det.rect;
      ctx.strokeStyle = det.id === state.selectedId ? '#93e5d8' : (det.type === 'barcode' ? '#fbbf24' : '#60a5fa');
      ctx.lineWidth = det.id === state.selectedId ? 3 : 2;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(x, y-16, Math.max(60, ctx.measureText(det.fieldName || det.type).width + 12), 16);
      ctx.fillStyle = '#e6edf3';
      ctx.font = '12px ui-monospace';
      ctx.fillText((det.fieldName || det.type).toUpperCase(), x+6, y-4);
    }
    ctx.restore();
  }

  // ---------- PDF loading ----------
  $('#pdfFile').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const buf = await file.arrayBuffer();
    state.pdf = await pdfjsLib.getDocument({data: buf}).promise;
    $('#pageNum').max = state.pdf.numPages;
    $('#pageNum').value = 1;
    await renderPage();
  });

  $('#render').addEventListener('click', renderPage);

  // ---------- Auto-detect ----------
  $('#autodetect').addEventListener('click', async () => {
    state.detections = [];
    drawOverlay();
    await detectAll();
  });

  async function detectAll(){
    if (!state.page) return;
    const usePdfText = $('#usePdfText').checked;
    const useOCR = $('#useOCR').checked;
    const useBarcode = $('#useBarcode').checked;

    if (usePdfText) await detectTextFromPdfLayer();
    if (useOCR) await detectTextWithOCR();
    if (useBarcode) await detectBarcodes();

    refreshDetList();
    drawOverlay();
  }

  async function detectTextFromPdfLayer(){
    const textContent = await state.page.getTextContent();
    const viewport = state.page.getViewport({ scale: state.scale });

    for (const item of textContent.items){
      const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
      const x = tx[4];
      const y = tx[5] - item.height; // PDF origin bottom-left
      const w = item.width;
      const h = item.height;
      const str = (item.str || '').trim();
      if (!str) continue;
      addDetection({ type:'text', value:str, rect:{x,y,w,h}, conf:0.99 });
    }
  }

  async function detectTextWithOCR(){
    const dataURL = canvas.toDataURL('image/png');
    const { data: { lines } } = await Tesseract.recognize(dataURL, 'eng', { logger: m => console.debug(m) });
    for (const ln of lines){
      const { x0,y0,x1,y1 } = ln.bbox; // already top-left
      addDetection({ type:'text', value: ln.text.trim(), rect:{x:x0,y:y0,w:x1-x0,h:y1-y0}, conf: ln.confidence/100 });
    }
  }

  async function detectBarcodes(){
    const codeReader = new ZXing.BrowserBarcodeReader(undefined, { delayBetweenScanAttempts: 0 });
    const tempImg = new Image();
    tempImg.src = canvas.toDataURL('image/png');
    await new Promise(r => tempImg.onload = r);

    // Try multiple formats, including PDF_417
    const hints = new Map();
    hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
    const formats = [
      ZXing.BarcodeFormat.PDF_417,
      ZXing.BarcodeFormat.CODE_128,
      ZXing.BarcodeFormat.CODE_39,
      ZXing.BarcodeFormat.QR_CODE,
      ZXing.BarcodeFormat.EAN_13,
      ZXing.BarcodeFormat.EAN_8,
      ZXing.BarcodeFormat.ITF
    ];

    for (const fmt of formats){
      hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [fmt]);
      try{
        const luminanceSource = await codeReader['createBinaryBitmapFromImage'](tempImg);
        const result = ZXing.MultiFormatReader.decode(luminanceSource, hints);
        if (result){
          // bounding box is not given by this helper; approximate by scanning area
          addDetection({ type:'barcode', value: result.getText(), rect:{x:20,y:20,w:canvas.width-40,h:120}, conf:1.0, format: ZXing.BarcodeFormat[fmt] });
          break;
        }
      }catch(err){ /* continue */ }
    }
  }

  function addDetection(det){
    det.id = crypto.randomUUID();
    det.fieldName = det.fieldName || '';
    det.font = det.font || 'A';
    det.size = det.size || 10;
    det.align = det.align || 'L';
    state.detections.push(det);
  }

  // ---------- Detections list & editing ----------
  function refreshDetList(){
    const root = document.getElementById('detList');
    root.innerHTML = '';
    state.detections.forEach((d,i) => {
      const el = document.createElement('div');
      el.className = 'det';
      el.innerHTML = `
        <h4>#${i+1} <span class="badge">${d.type}</span></h4>
        <div class="row">
          <input type="text" placeholder="Field name (e.g., SURNAME, FLTNO, BCBP)" value="${d.fieldName}" data-k="fieldName" data-id="${d.id}" />
        </div>
        <div class="row" style="margin-top:6px">
          <input type="text" class="kbd" value="${(d.value||'').replace(/\"/g,'&quot;')}" data-k="value" data-id="${d.id}" />
        </div>
        <div class="row" style="margin-top:6px">
          <input type="number" value="${Math.round(d.rect.x)}" data-k="x" data-id="${d.id}" />
          <input type="number" value="${Math.round(d.rect.y)}" data-k="y" data-id="${d.id}" />
          <input type="number" value="${Math.round(d.rect.w)}" data-k="w" data-id="${d.id}" />
          <input type="number" value="${Math.round(d.rect.h)}" data-k="h" data-id="${d.id}" />
        </div>
        <div class="row" style="margin-top:6px">
          <select data-k="font" data-id="${d.id}">
            <option ${d.font==='A'?'selected':''}>A</option>
            <option ${d.font==='B'?'selected':''}>B</option>
            <option ${d.font==='C'?'selected':''}>C</option>
          </select>
          <input type="number" value="${d.size}" data-k="size" data-id="${d.id}" />
          <select data-k="align" data-id="${d.id}">
            <option value="L" ${d.align==='L'?'selected':''}>Left</option>
            <option value="C" ${d.align==='C'?'selected':''}>Center</option>
            <option value="R" ${d.align==='R'?'selected':''}>Right</option>
          </select>
          <button data-id="${d.id}" class="del">Delete</button>
        </div>
        <small>Box: x,y,w,h</small>
      `;
      root.appendChild(el);
    });

    root.querySelectorAll('input,select,textarea,button').forEach(el => {
      const id = el.dataset.id;
      if (!id) return;
      if (el.classList.contains('del')){
        el.addEventListener('click', () => {
          state.detections = state.detections.filter(d => d.id !== id);
          refreshDetList(); drawOverlay();
        });
      } else {
        el.addEventListener('input', () => {
          const k = el.dataset.k;
          const det = state.detections.find(d => d.id === id);
          if (!det) return;
          if (k === 'x' || k==='y' || k==='w' || k==='h') det.rect[k] = Number(el.value);
          else det[k] = el.value;
          drawOverlay();
        });
      }
    });
  }

  // ---------- Canvas selection (draw boxes) ----------
  let drag = null;
  canvas.addEventListener('mousedown', (e)=>{
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    drag = {x,y};
  });
  window.addEventListener('mousemove', (e)=>{
    if (!drag) return;
    const r = canvas.getBoundingClientRect();
    const x2 = e.clientX - r.left, y2 = e.clientY - r.top;
    const rect = {x:Math.min(drag.x,x2), y:Math.min(drag.y,y2), w:Math.abs(x2-drag.x), h:Math.abs(y2-drag.y)};
    // Temp drawing
    renderPage().then(()=>{ ctx.save(); ctx.strokeStyle='#6ee7b7'; ctx.setLineDash([6,4]); ctx.strokeRect(rect.x,rect.y,rect.w,rect.h); ctx.restore(); });
  });
  window.addEventListener('mouseup', (e)=>{
    if (!drag) return;
    const r = canvas.getBoundingClientRect();
    const x2 = e.clientX - r.left, y2 = e.clientY - r.top;
    const rect = {x:Math.min(drag.x,x2), y:Math.min(drag.y,y2), w:Math.abs(x2-drag.x), h:Math.abs(y2-drag.y)};
    drag = null;
    addDetection({ type:'text', value:'', rect, conf:0.5 });
    refreshDetList(); drawOverlay();
  });
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'Delete' && state.selectedId){
      state.detections = state.detections.filter(d=>d.id!==state.selectedId);
      state.selectedId = null; refreshDetList(); drawOverlay();
    }
  });
  canvas.addEventListener('click', (e)=>{
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    // hit test
    for (const d of [...state.detections].reverse()){
      const {x:dx,y:dy,w,h} = d.rect;
      if (x>=dx && x<=dx+w && y>=dy && y<=dy+h){ state.selectedId = d.id; drawOverlay(); return; }
    }
    state.selectedId = null; drawOverlay();
  });

  // ---------- Presets ----------
  function addPreset(type){
    const presets = type==='ATB' ? [
      {fieldName:'SURNAME', font:'A', size:12},
      {fieldName:'GIVEN', font:'A', size:12},
      {fieldName:'FLTNO', font:'B', size:12},
      {fieldName:'DATE', font:'B', size:12},
      {fieldName:'FROM', font:'B', size:12},
      {fieldName:'TO', font:'B', size:12},
      {fieldName:'SEAT', font:'B', size:12},
      {fieldName:'SEQ', font:'B', size:12},
      {fieldName:'BCBP', type:'barcode'}
    ] : [
      {fieldName:'NAME', font:'A', size:12},
      {fieldName:'TAG', font:'B', size:12},
      {fieldName:'ORIGIN', font:'B', size:12},
      {fieldName:'DEST', font:'B', size:12},
      {fieldName:'FLIGHT', font:'B', size:12},
      {fieldName:'BAGCNT', font:'B', size:12},
      {fieldName:'BARCODE', type:'barcode'}
    ];

    for (const p of presets){ addDetection({ type: p.type || 'text', value:'', rect:{x:40,y:40,w:160,h:24}, conf:1, font:p.font, size:p.size, fieldName:p.fieldName }); }
    refreshDetList(); drawOverlay();
  }
  $('#presetATB').addEventListener('click', ()=>addPreset('ATB'));
  $('#presetBTP').addEventListener('click', ()=>addPreset('BTP'));

  // ---------- Export: PECTAB layout + data ----------
  function toPECTAB(){
    // NOTE: This generates a *draft* PECTAB (ATB/BTP) layout syntax that many editors accept.
    // Coordinates are in pixels at the current render scale, origin=top-left.
    // You may need to fine-tune fonts/sizes in your downstream PECTAB tool.
    const L = [];
    L.push('AD; // Begin PECTAB');
    for (const d of state.detections){
      const {x,y,w,h} = d.rect; const X=Math.round(x), Y=Math.round(y), W=Math.round(w), H=Math.round(h);
      if (d.type==='barcode'){
        // B: Barcode block — using PDF417 by default
        L.push(`B; TYPE=PDF417; X=${X}; Y=${Y}; W=${W}; H=${H}; FIELD=${d.fieldName||'BARCODE'};`);
      } else {
        // T: Text block — font family A/B/C are placeholders used by many PECTAB tools
        const val = d.value ? d.value.replace(/"/g,'\"') : `#{${(d.fieldName||'FIELD').toUpperCase()}}`;
        L.push(`T; FONT=${d.font||'A'}; SIZE=${d.size||10}; X=${X}; Y=${Y}; W=${W}; H=${H}; ALIGN=${d.align||'L'}; FIELD=${(d.fieldName||'TEXT')}; TEXT="${val}";`);
      }
    }
    L.push('ED; // End PECTAB');
    return L.join('\n');
  }

  function toDataString(){
    // Very light-weight mapping to generate an ATB/BTP-like data string from known fields.
    // You can customize this function per airline/airport needs.
    const F = Object.fromEntries(state.detections.map(d=>[d.fieldName?.toUpperCase()||'', (d.value||'').trim()]));

    // Example ATB: BTP010101#01HU/HAISHENGMR#... (purely illustrative)
    const parts = [];
    if (F.SURNAME || F.GIVEN) parts.push(`${(F.SURNAME||'')}${F.GIVEN?('/'+F.GIVEN):''}`);
    if (F.FLTNO) parts.push(`FLT${F.FLTNO}`);
    if (F.DATE) parts.push(`DT${F.DATE}`);
    if (F.FROM && F.TO) parts.push(`${F.FROM}-${F.TO}`);
    if (F.SEAT) parts.push(`SEAT${F.SEAT}`);
    if (F.SEQ) parts.push(`SEQ${F.SEQ}`);
    if (F.BCBP) parts.push(`BCBP:${F.BCBP}`);

    // Barcode fallback becomes BCBP if not explicitly mapped
    if (!F.BCBP){ const bc = state.detections.find(d=>d.type==='barcode'); if (bc) parts.push(`BCBP:${(bc.value||'').trim()}`); }

    return parts.filter(Boolean).join(' | ');
  }

  $('#exportPectab').addEventListener('click', ()=>{
    $('#pectabOut').value = toPECTAB();
    $('#dataOut').value = toDataString();
  });

  $('#exportJSON').addEventListener('click', ()=>{
    const payload = { scale: state.scale, pageNum: state.pageNum, detections: state.detections };
    const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'pectab-export.json'; a.click(); URL.revokeObjectURL(url);
  });

  $('#clearAll').addEventListener('click', ()=>{ state.detections=[]; refreshDetList(); drawOverlay(); });

  // ---------- Init message ----------
  (function(){ console.log('%cPDF → PECTAB Converter ready','color:#5eead4'); })();
  </script>
</body>
</html>

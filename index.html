<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>pdf2pectab — PDF → PECTAB (client‑side)</title>
  <style>
    :root{--bg:#0b0e12;--panel:#121720;--ink:#e6eefc;--muted:#9fb1ca;--brand:#5ea1ff;--accent:#7cf;--warn:#ffd66b;--danger:#ff7a7a}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 18px;background:linear-gradient(180deg,#0f1420 0%,#0b0e12 100%);border-bottom:1px solid #1b2332}
    header .title{font-weight:700;font-size:16px;letter-spacing:.3px}
    header .badge{font-size:12px;color:var(--bg);background:var(--brand);padding:2px 8px;border-radius:999px}
    main{display:grid;grid-template-columns:360px 1fr;gap:14px;padding:14px;height:calc(100% - 60px)}
    aside,section{background:var(--panel);border:1px solid #1b2332;border-radius:14px;overflow:hidden}
    aside{display:flex;flex-direction:column}
    .pane-head{padding:12px 14px;border-bottom:1px solid #1b2332;font-weight:600;display:flex;justify-content:space-between;align-items:center}
    .pane-body{padding:12px;gap:12px;display:flex;flex-direction:column;overflow:auto}
    label{display:block;margin-bottom:6px;color:var(--muted);font-size:12px}
    input[type=file],select,button,.textlike{width:100%;padding:10px 12px;background:#0e131c;border:1px solid #243149;color:var(--ink);border-radius:10px}
    button{cursor:pointer} button.primary{background:var(--brand);color:#08111f;border-color:#4e86d6;font-weight:700}
    button.ghost{background:transparent;border-color:#243149}
    button.warn{background:var(--warn);color:#1a1400;border-color:#c1a23f}
    .row{display:flex;gap:10px}
    .row>div{flex:1}
    #canvasWrap{position:relative;height:100%;display:flex;flex-direction:column}
    #pdfCanvas{flex:1;background:#0a0f18;border-bottom:1px solid #1b2332}
    #overlay{position:absolute;inset:0;pointer-events:auto;z-index:10}
    .toolbar{display:flex;gap:8px;padding:8px;border-bottom:1px solid #1b2332;background:#0e141f}
    .pill{padding:8px 10px;border:1px solid #2a3a55;border-radius:999px;background:#101826;cursor:pointer;color:var(--muted)}
    .pill.active{background:#162235;color:var(--ink);border-color:#3a5786}
    .item{padding:8px 10px;border:1px solid #26344c;border-radius:10px;display:flex;align-items:center;justify-content:space-between}
    .item small{color:var(--muted)}
    .list{display:flex;flex-direction:column;gap:8px}
    .hint{color:var(--muted);font-size:12px}
    .tag{font-size:11px;padding:2px 6px;border-radius:6px;background:#1b2a45;color:#b8d0ff;border:1px solid #2a3a55}
    .grid{position:absolute;inset:0;pointer-events:none;background-image:linear-gradient(to right, rgba(126,193,255,.06) 1px, transparent 1px),linear-gradient(to bottom, rgba(126,193,255,.06) 1px, transparent 1px);background-size:40px 40px;mix-blend:screen;z-index:5}
    .bbox{position:absolute;border:1px dashed #7cf;outline:9999px solid rgba(124,255,255,.05);border-radius:4px}
    .bbox .label{position:absolute;left:0;top:-18px;background:#162235;border:1px solid #2f4d79;color:#bfe9ff;font-size:11px;padding:1px 6px;border-radius:6px}
    .danger{color:var(--danger)} .success{color:#7cffc2}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hr{height:1px;background:#1b2332;margin:6px 0}
    .footer{padding:8px 12px;border-top:1px solid #1b2332;display:flex;gap:8px;justify-content:flex-end}
  </style>
  <!-- PDF.js (UMD build) -->
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
</head>
<body>
  <header>
    <div class="title">pdf2pectab <span class="badge">alpha</span></div>
    <div class="hint">All processing is client‑side. Share this page via GitHub Pages.</div>
  </header>
  <main>
    <aside>
      <div class="pane-head">Input & Settings</div>
      <div class="pane-body">
        <div>
          <label>Upload PDF (single page, correct physical size)</label>
          <input id="file" type="file" accept="application/pdf" />
        </div>
        <div class="row">
          <div>
            <label>Printer DPI</label>
            <select id="dpi">
              <option value="203" selected>203</option>
              <option value="300">300</option>
            </select>
          </div>
          <div>
            <label>Template ID</label>
            <input id="templateId" class="textlike" value="BT01" />
          </div>
        </div>
        <div>
          <label>Dynamic field tagging</label>
          <div class="hint">If your PDF has AcroForm fields, click “Parse Forms”. Otherwise, add regions on the canvas and tag them.</div>
          <div class="row">
            <button id="btnParseForms" class="ghost">Parse Forms</button>
            <button id="btnClearBBoxes" class="ghost">Clear Tagged Regions</button>
          </div>
        </div>
        <div>
          <label>Elements (auto + manual)</label>
          <div id="elemList" class="list"></div>
        </div>
        <div class="hr"></div>
        <div>
          <label>Background</label>
          <div class="hint">Optionally print the PDF artwork as a bitmap background. Warning: keep barcodes/text you want dynamic OUT of the bitmap or punch out white pads.</div>
          <div class="row">
            <button id="btnExportBG" class="ghost">Export BG Bitmap</button>
            <button id="btnToggleBGPreview" class="ghost">Preview On/Off</button>
          </div>
        </div>
        <div class="hr"></div>
        <div>
          <label>Export</label>
          <div class="row">
            <button id="btnExportPectab" class="primary">Export PECTAB</button>
            <button id="btnExportManifest" class="ghost">Export Manifest JSON</button>
          </div>
          <div class="hint">Note: PECTAB dialects vary slightly by printer/firmware. Adjust the export mapping if needed.</div>
        </div>
      </div>
    </aside>

    <section id="canvasWrap">
      <div class="pane-head" style="display:flex;align-items:center;gap:10px">
        <div>PDF Preview & Tagging</div>
        <div class="toolbar" style="margin-left:auto">
          <div class="pill active" data-tool="pan">Pan</div>
          <div class="pill" data-tool="text">Add Text</div>
          <div class="pill" data-tool="barcode">Add Barcode</div>
          <div class="pill" data-tool="box">Add Box/Line</div>
          <div class="pill" data-tool="erase">Erase</div>
        </div>
      </div>
      <div style="position:relative;flex:1;min-height:320px">
        <canvas id="pdfCanvas"></canvas>
        <div id="overlay"></div>
        <div class="grid" id="grid"></div>
      </div>
      <div class="footer">
        <span id="pageMeta" class="hint"></span>
        <div style="flex:1"></div>
        <button id="btnFit" class="ghost">Fit width</button>
        <button id="btn100" class="ghost">100%</button>
      </div>
    </section>
  </main>

<script>
  // --- PDF setup ---
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

  // DOM refs
  const fileEl = document.getElementById('file');
  const dpiEl = document.getElementById('dpi');
  const templateIdEl = document.getElementById('templateId');
  const canvas = document.getElementById('pdfCanvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const elemList = document.getElementById('elemList');
  const pageMeta = document.getElementById('pageMeta');

  const btnExportBG = document.getElementById('btnExportBG');
  const btnToggleBGPreview = document.getElementById('btnToggleBGPreview');

  let pdf, page, viewport, scale=1, pdfBytes;
  let pagePtsW = 0, pagePtsH = 0; // PDF points
  let boxes = []; // user-tagged regions
  let tool = 'pan';
  let pan = {active:false, x:0,y:0, ox:0,oy:0};
  let bgPreviewOn = false;

  // Tool switching UI
  document.querySelectorAll('.pill').forEach(el=>{
    el.addEventListener('click',()=>{
      document.querySelectorAll('.pill').forEach(p=>p.classList.remove('active'));
      el.classList.add('active');
      tool = el.dataset.tool;
    });
  });

  // File upload
  fileEl.addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    try {
      pdfBytes = await f.arrayBuffer();
      pdf = await pdfjsLib.getDocument({data: pdfBytes}).promise;
      page = await pdf.getPage(1);
      const vp = page.getViewport({scale:1});
      pagePtsW = vp.viewBox[2];
      pagePtsH = vp.viewBox[3];
      fitWidth();
      await render();
      boxes = [];
      refreshElemList();
    } catch (err) {
      console.error('PDF load/render error:', err);
      alert('Sorry — failed to read this PDF. Check that it\'s a single-page PDF and try again. See console for details.');
    }
  });
    pdf = await pdfjsLib.getDocument({data: pdfBytes}).promise;
    page = await pdf.getPage(1);

    // Get page size (in points) and viewport
    const vp = page.getViewport({scale:1});
    pagePtsW = vp.viewBox[2];
    pagePtsH = vp.viewBox[3];

    // Initial render: fit width
    fitWidth();
    await render();
    boxes = [];
    refreshElemList();
  });

  async function render(){
    if(!page) return;
    try {
      viewport = page.getViewport({scale});
      canvas.width = Math.max(1, Math.floor(viewport.width));
      canvas.height = Math.max(1, Math.floor(viewport.height));
      overlay.style.width = canvas.width + 'px';
      overlay.style.height = canvas.height + 'px';
      const renderTask = page.render({canvasContext: ctx, viewport});
      await renderTask.promise;
      pageMeta.textContent = `Page: ${Math.round(pagePtsW)}×${Math.round(pagePtsH)} pt  |  Zoom: ${(scale*100).toFixed(0)}%`;
    } catch (err) {
      console.error('Render failed:', err);
      alert('Render failed — see console for details.');
    }
  });
    canvas.width = Math.max(1, Math.floor(viewport.width));
    canvas.height = Math.max(1, Math.floor(viewport.height));
    overlay.style.width = canvas.width + 'px';
    overlay.style.height = canvas.height + 'px';

    const renderTask = page.render({canvasContext: ctx, viewport});
    await renderTask.promise;
    pageMeta.textContent = `Page: ${Math.round(pagePtsW)}×${Math.round(pagePtsH)} pt  |  Zoom: ${(scale*100).toFixed(0)}%`;
  }

  function fitWidth(){
    const wrap = document.getElementById('canvasWrap');
    const w = wrap.clientWidth - 20; // padding
    const vp = page.getViewport({scale:1});
    scale = w / vp.width;
  }

  document.getElementById('btnFit').onclick = async ()=>{fitWidth(); await render(); drawBoxes();};
  document.getElementById('btn100').onclick = async ()=>{scale = 1; await render(); drawBoxes();};

  // Pan & draw interactions
  overlay.addEventListener('mousedown',(e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if(tool==='pan'){
      pan = {active:true,x,y,ox:window.scrollX,oy:window.scrollY};
      return;
    }
    if(tool==='erase'){
      // Erase box under cursor
      const i = boxes.findIndex(b=>x>=b.x && y>=b.y && x<=b.x+b.w && y<=b.y+b.h);
      if(i>=0){ boxes.splice(i,1); drawBoxes(); refreshElemList(); }
      return;
    }

    // Start drawing new region
    const b = {x,y,w:0,h:0,type:tool, name:"", opts:{}, id:crypto.randomUUID()};
    boxes.push(b);
    const move = (ev)=>{
      b.w = (ev.clientX - rect.left) - x;
      b.h = (ev.clientY - rect.top) - y;
      drawBoxes();
    };
    const up = async()=>{
      window.removeEventListener('mousemove',move);
      window.removeEventListener('mouseup',up);
      // Normalize w/h positive
      if(b.w<0){ b.x+=b.w; b.w*=-1; }
      if(b.h<0){ b.y+=b.h; b.h*=-1; }
      drawBoxes();
      await promptBoxMeta(b);
      refreshElemList();
    };
    window.addEventListener('mousemove',move);
    window.addEventListener('mouseup',up);
  });

  window.addEventListener('mousemove',(e)=>{
    if(!pan.active) return;
    window.scrollTo(pan.ox - (e.clientX - pan.x), pan.oy - (e.clientY - pan.y));
  });
  window.addEventListener('mouseup',()=> pan.active=false);

  function drawBoxes(){
    overlay.innerHTML = '';
    boxes.forEach(b=>{
      const el = document.createElement('div');
      el.className = 'bbox';
      el.style.left = `${b.x}px`; el.style.top = `${b.y}px`;
      el.style.width = `${b.w}px`; el.style.height = `${b.h}px`;
      const lab = document.createElement('div');
      lab.className='label';
      lab.textContent = `${b.type.toUpperCase()} ${b.name?('· '+b.name):''}`;
      el.appendChild(lab);
      overlay.appendChild(el);
    });
  }

  async function promptBoxMeta(b){
    const name = prompt(`Name for this ${b.type} region (e.g., FLIGHT, LPN, FROM_TO)`, b.name||'');
    if(name!==null) b.name = name.trim();
    if(b.type==='barcode'){
      const sym = prompt('Barcode symbology (e.g., CODE128, QR, PDF417)', b.opts.symbology||'CODE128');
      const mod = prompt('Module width in dots (e.g., 2)', b.opts.module||'2');
      b.opts.symbology = (sym||'CODE128').toUpperCase();
      b.opts.module = parseInt(mod||'2',10);
    }
  }

  function refreshElemList(){
    elemList.innerHTML='';
    if(!boxes.length){ elemList.innerHTML = '<div class="hint">No tagged regions yet. Use tools above to add Text / Barcode / Box.</div>'; return; }
    boxes.forEach(b=>{
      const item = document.createElement('div');
      item.className='item';
      const xywh = `${Math.round(b.x)},${Math.round(b.y)} ${Math.round(b.w)}×${Math.round(b.h)}`;
      item.innerHTML = `<div><div><strong>${b.name||'(unnamed)'}</strong> <span class="tag">${b.type}</span></div><small>${xywh} px @ current zoom</small></div><button class="ghost">Edit</button>`;
      item.querySelector('button').onclick = async()=>{ await promptBoxMeta(b); drawBoxes(); refreshElemList(); };
      elemList.appendChild(item);
    });
  }

  // Parse AcroForm widgets into boxes
  document.getElementById('btnParseForms').onclick = async()=>{
    if(!page){ alert('Load a PDF first.'); return; }
    const annots = await page.getAnnotations();
    if(!annots.length){ alert('No annotations/forms found.'); return; }

    const vp = page.getViewport({scale});
    annots.forEach(a=>{
      if(!a.rect) return;
      const [x1,y1,x2,y2] = a.rect;
      const wPts = x2-x1, hPts = y2-y1;
      const xPx = (x1 / pagePtsW) * vp.width;
      const yPx = vp.height - ((y1 + hPts) / pagePtsH) * vp.height; // flip Y
      const wPx = (wPts / pagePtsW) * vp.width;
      const hPx = (hPts / pagePtsH) * vp.height;
      boxes.push({x:xPx,y:yPx,w:wPx,h:hPx,type:'text',name:a.fieldName||a.title||'FIELD',opts:{}, id:crypto.randomUUID()});
    });
    drawBoxes();
    refreshElemList();
  };

  document.getElementById('btnClearBBoxes').onclick=()=>{ boxes=[]; drawBoxes(); refreshElemList(); };

  // --- Export helpers ---
  function toDots(px){
    // Convert from on-screen pixels back to PDF points, then to printer dots
    const pts = (px / viewport.width) * pagePtsW; // proportional to current viewport
    const dots = Math.round( pts * (parseInt(dpiEl.value,10) / 72) );
    return dots;
  }

  function exportPectab(){
    if(!page){ alert('Load a PDF first.'); return; }
    const dpi = parseInt(dpiEl.value,10);
    const Wdots = Math.round(pagePtsW * dpi / 72);
    const Hdots = Math.round(pagePtsH * dpi / 72);

    const lines = [];
    lines.push(`; PECTAB template generated by pdf2pectab (alpha)`);
    lines.push(`; Media: ${Wdots}x${Hdots} dots @ ${dpi} dpi`);
    lines.push(`PT;ID=${templateIdEl.value}`);
    lines.push(`PAGE;W=${Wdots};H=${Hdots}`);
    lines.push(`; If you exported a background bitmap, download it once to the printer as ID=BG1 and place it at 0,0`);
    lines.push(`; Example: BITMAP;ID=BG1;X=0;Y=0;W=${Wdots};H=${Hdots}`);

    boxes.forEach(b=>{
      const x = toDots(b.x);
      const y = toDots(b.y);
      const w = toDots(b.w);
      const h = toDots(b.h);
      if(b.type==='text'){
        const font = 'A1';
        const size = Math.max(8, Math.round(h*0.8));
        const token = (b.name||'TEXT').toUpperCase();
        lines.push(`TEXT;X=${x};Y=${y};W=${w};H=${h};FONT=${font};SIZE=${size};ALIGN=LT;DATA=%${token}%`);
      } else if(b.type==='barcode'){
        const token = (b.name||'BAR').toUpperCase();
        const sym = (b.opts.symbology||'CODE128').toUpperCase();
        const mod = Number.isFinite(b.opts.module)? b.opts.module : 2;
        lines.push(`BARCODE;TYPE=${sym};X=${x};Y=${y};W=${w};H=${h};MODULE=${mod};DATA=%${token}%`);
      } else if(b.type==='box'){
        const t = Math.max(1, Math.round(Math.min(w,h)*0.04));
        lines.push(`BOX;X=${x};Y=${y};W=${w};H=${h};T=${t}`);
      }
    });

    lines.push(`PS;ID=${templateIdEl.value}`);

    const blob = new Blob([lines.join('
')], {type:'text/plain'});
    downloadBlob(blob, `${templateIdEl.value}.pectab.txt`);
  }

  // Background export: rasterize PDF to dots, threshold to B/W, download PNG and helper PECTAB snippet
  async function exportBG(){
    if(!page){ alert('Load a PDF first.'); return; }
    const dpi = parseInt(dpiEl.value,10);
    const Wdots = Math.round(pagePtsW * dpi / 72);
    const Hdots = Math.round(pagePtsH * dpi / 72);

    try {
      // Render at 1:1 printer dots resolution
      const scaleDots = Wdots / pagePtsW; // dots per point
      const vp = page.getViewport({scale: scaleDots});
      const off = document.createElement('canvas');
      off.width = Math.max(1, Math.floor(vp.width));
      off.height = Math.max(1, Math.floor(vp.height));
      const octx = off.getContext('2d', { willReadFrequently: true });
      await page.render({canvasContext: octx, viewport: vp}).promise;

      // Convert to pure black & white (1-bit style)
      const img = octx.getImageData(0,0,off.width,off.height);
      for(let i=0;i<img.data.length;i+=4){
        const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
        const y = 0.2126*r + 0.7152*g + 0.0722*b;
        const v = y < 140 ? 0 : 255; // threshold ~55%
        img.data[i]=img.data[i+1]=img.data[i+2]=v; img.data[i+3]=255;
      }
      octx.putImageData(img,0,0);

      // Download bitmap as PNG and helper PECTAB snippet
      off.toBlob((blob)=>{ if(blob) downloadBlob(blob, 'BG1.png'); }, 'image/png');

      const helper = [
        `; Download BG1.png to your printer as bitmap resource ID=BG1 (device-specific)`,
        `; Then place it at origin before other elements:`,
        `BITMAP;ID=BG1;X=0;Y=0;W=${Wdots};H=${Hdots}`
      ].join('
');
      downloadBlob(new Blob([helper],{type:'text/plain'}), 'BG1.pectab-snippet.txt');
    } catch (err) {
      console.error('Background export failed:', err);
      alert('Background export failed — see console for details.');
    }
  }
    const dpi = parseInt(dpiEl.value,10);
    const Wdots = Math.round(pagePtsW * dpi / 72);
    const Hdots = Math.round(pagePtsH * dpi / 72);

    // Render at 1:1 dot resolution
    const scaleDots = Wdots / page.view[2];
    const vp = page.getViewport({scale: scaleDots});
    const off = document.createElement('canvas');
    off.width = Math.max(1, Math.floor(vp.width));
    off.height = Math.max(1, Math.floor(vp.height));
    const octx = off.getContext('2d', { willReadFrequently: true });
    await page.render({canvasContext: octx, viewport: vp}).promise;

    // Convert to pure black & white (1-bit style)
    const img = octx.getImageData(0,0,off.width,off.height);
    for(let i=0;i<img.data.length;i+=4){
      const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
      const y = 0.2126*r + 0.7152*g + 0.0722*b;
      const v = y < 140 ? 0 : 255; // threshold ~55%
      img.data[i]=img.data[i+1]=img.data[i+2]=v; img.data[i+3]=255;
    }
    octx.putImageData(img,0,0);

    // Download bitmap as PNG and helper PECTAB
    off.toBlob((blob)=>{ downloadBlob(blob, 'BG1.png'); }, 'image/png');

    const helper = [
      `; Download BG1.png to your printer as bitmap resource ID=BG1 (device-specific)` ,
      `; Then place it at origin before other elements:`,
      `BITMAP;ID=BG1;X=0;Y=0;W=${Wdots};H=${Hdots}`
    ].join('
');
    downloadBlob(new Blob([helper],{type:'text/plain'}), 'BG1.pectab-snippet.txt');
  }

  btnExportBG.addEventListener('click', exportBG);
  btnToggleBGPreview.addEventListener('click', ()=>{
    bgPreviewOn = !bgPreviewOn;
    document.getElementById('grid').style.opacity = bgPreviewOn ? 0.2 : 1;
  });

  function exportManifest(){
    const dpi = parseInt(dpiEl.value,10);
    const Wdots = Math.round(pagePtsW * dpi / 72);
    const Hdots = Math.round(pagePtsH * dpi / 72);
    const fields = boxes.map(b=>({
      id: b.id,
      type: b.type,
      name: b.name,
      x: toDots(b.x), y: toDots(b.y), w: toDots(b.w), h: toDots(b.h),
      opts: b.opts
    }));
    const manifest = { templateId: templateIdEl.value, media:{dotsW:Wdots,dotsH:Hdots,dpi}, fields };
    const blob = new Blob([JSON.stringify(manifest,null,2)], {type:'application/json'});
    downloadBlob(blob, `${templateIdEl.value}.manifest.json`);
  }

  function downloadBlob(blob, filename){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename; a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }

  document.getElementById('btnExportPectab').onclick = exportPectab;
  document.getElementById('btnExportManifest').onclick = exportManifest;
</script>
</body>
</html>
